{"./":{"url":"./","title":"Unita Introduction","keywords":"","body":"Unita Introduction What is Unita Unita is an enterprise blockchain solution. It's featured of high TPS (Transactions Per Second) and low transaction confirmation time, to make DApps (Decentralized Applications) applicable to more business scenarios. Meanwhile, by using a consensus algorithm named SCAR (Scalable Consensus Algorithm), storage and network consumption are minimized, so as to reduce operating costs. It’s developed on the basis of the open-source project, Qtum, which is compatible with the Bitcoin UTXO data structure and Ethereum Solidity smart contracts. Resource Tool: Homepage, Stats, Explorer, Faucet, One-click Blockchain. Document: English, 中文. Roadmap Develop the blockchain system, with SCAR consensus. (Done) Build related tools, including Stats, Explorer, Faucet, One-click Blockchain and etc.. (Done) Develop a demo kit, to show how to build business applications based on Unita. (Doing) Upload Unita to cloud service providers, like AWS and Google Cloud, to make the system deployment more convenient. (Todo) Develop the cross-chain solution, Canal. (Todo) Develop the data management solution, DDAO. (Todo) Start courses, guiding how to develop programs on Unita. (Todo) "},"SCAR-Consensus/":{"url":"SCAR-Consensus/","title":"SCAR: Scalable Consensus Algorithm","keywords":"","body":"SCAR: Scalable Consensus Algorithm Background In order to reduce the fork attack and ensure the reliability of the blockchain network, the block intervals of some well-kown blockchain consensus algorithms, like PoS and PoW, are more than 10 seconds. For example: the block time interval of Ethereum is 15 seconds, the Qtum is 144 seconds and the Bitcoin is 10 minutes. Howerver, the longer the block interval is, the longer the user will be waiting for the transaction confirmation. It is not good for real-time payment and some other applications. Some consensus algorithms of the consortium blockchain, such as DPoS(Delegated Proof of Stake) [1] and Aura (Authority Round) [2] , reduce the block interval to less than 1 second by voting for the super node to execute the consensus algorithm. But the problem with this is that the number of blocks is too large, which puts a lot of pressure on network and storage. Running a full node, or even a light node that only downloads the block header, has high requirements on the performance of the node device. For most commercial applications of blockchains, such as credit record and commodity tracking, the write operations to blockchains are usually periodic. That is to say, the trading volume is large in hours of the day, and the trading volume is small in the remaining hours. For such a scenario, if the high-speed block output is always maintained, it is a big waste for the network and storage resources, and we only ensure that the system has higher performance during the peak hours of the network. Therefore, we propose the SCAR (Scalable Consensus Algorithm). The idea of SCAR is to adjust parameters dynamically to find a balance between high performance and low load to achieve performance scalability. Related Work PoW is represented by Bitcoin. The node provides computational power to generate new blocks through a large number of calculations. The higher the power is provided, the faster the block is generated. The calculation difficulty is adjusted every 2016 blocks, ensuring that the block time interval is kept at around 10 minutes in the case of a change in the overall network computing power. Since the block interval is long and the size of each block is limited to 1 MB. Therefore, the network will be seriously congested when the transaction volume is large. PoS is represented by Qtum. The node provides a token and generates a new block with a small amount of calculation. The larger the token amount is, the faster the block is generated. The calculation difficulty will also be adjusted periodically to ensure that the block time interval is around 144 seconds. Compared with PoW, PoS is more energy efficient since it reduces the computational power requirements. However, since the block interval and the block size limit are still fixed, the load on the network is fixed, and it is impossible to avoid congestion when the transaction volume is large. Although Qtum can manually adjust the block size limit using the DGP(Decentralized Governance Protocol)[3] protocol, this approach is not easy enough. In PoW and PoS, all nodes of the whole network will participate in the consensus competition, so the block interval cannot be set too small. If it is too small, it is easy to produce a fork. In other words, if the calculation difficulty is set too low, it is easy for a plurality of nodes to generate a new block at the same time. The consortium blockchain consensus algorithm, such as DPoS and Tendermint, performs consensus by voting the super nodes. Since the number of nodes participating in the consensus is small, the block interval can be set small. For example, the EOS block interval is set to 0.5s. Too short a block interval is a great pressure on bandwidth and hard disk, and it will lead to waste of resources when the transaction volume is small. Since the launch of EOS on June 9 this year, the number of blocks has reached 12 million, but Bitcoin, which started 9 years ago, has only 500,000 blocks. Algorithm Description An implementation of the SCAR algorithm will be described below. Based on the consortium blockchain, this algorithm dynamically updates the block interval by the transaction volume. It should be noted that the core idea of the SCAR algorithm is to dynamically adjust the performance of the blockchain according to the network load, so the implementation is not limited to the one proposed in this paper, and more implementations need to be further explored. There are three steps in SCAR: Count all votes to get the super nodes. Calculate the block interval based on the network load. When the interval is over, each super node try to generate a block according to the priority. Once a new block is generated, return to step 1. The advantages of the SCAR: Consensus is implemented by the super nodes, the block interval can be greatly shortened, and the transaction confirmation is faster. The block interval is dynamically adjusted according to the network load. When the network load is reduced, the block interval becomes longer. It will reduce the bandwidth and hard disk pressure. When less than half of the super nodes are fail, the new block can still be produced, and the system is still robust. The detail of three steps of the SCAR algorithm will be described separately below. Vote for super nodes There are many ways to vote for super nodes. For example, in EOS all users can vote, and in Aura current super nodes can vote for super nodes of next round. Here we propose a voting strategy based on the Qtum DGP protocol. When a new blockchain is initialized, the DGP's smart contract is deployed on the chain, and all admins (administrators) and govs (governors) are initialized in the contract. They are stored in the form of addresses. The DGP protocol supports on-chain voting by these admins and govs to determine if the super nodes should be updated. First, we will introduce the permissions and modification strategies of the admins and govs. The admins have the highest power to determine the authority. The admins can participate in voting to add and delete admins, govs and super nodes; and the govs can only vote for super nodes. The voting process is as follows: Collect new super node proposals, publish to the community and collect feedback; Adjust the list of super nodes based on community feedback and store them in the blockchain through smart contracts as a new proposal; Call the corresponding method of the DGP contract to set the proposal to be voted, and the voting is started at this time; Every admin and gov votes on the proposal by sending a transaction to the voting contract; If the proposal does not receive enough votes, it will be rejected and no amendments will be implemented; If the proposal passes, the storage address of the new super node list will be recorded in the DGP contract and will take effect after a certain number of blocks to prevent unnecessary forks. Every node can get the latest list of super nodes through the DGP contract. In summary, we can deploy DGP contract on the blockchain, determine the super nodes by DGP voting. And then, we can store and update the list of authorized nodes dynamically . Block interval The interval of the block needs to be dynamically adjusted according to the load of the network. When the network is busy, the interval becomes shorter. We propose a calculation method of block interval in this paper, which is calculated according to the number of recent transactions. The formula for calculating the block interval is as follows: In this formula, min_interval is the minimum block time interval, and max_interval is the maximum block time interval. transaction_num is the average number of transactions in the last m blocks, and m can be an integer greater than or equal to 1. These parameters (m, min_interval, and max_interval) are pre-set by consensus algorithms or smart contract. The meaning of this formula is: When the transaction_num is 0, the block interval will be adjusted to max_interval. At this time, the maximum interval set by the system will be used to pack transactions in one block as much as possible. It can avoid waste of storage resource; When the transaction_num tends to infinity, the block interval will infinitely approach min_interval, and the shortest interval set by the system will be used to ease the transaction congestion of the blockchain network as much as possible. max_interval and min_interval can be set according to the actual situation (such as user tolerated transaction delay, super node network environment and storage performance, etc.). By using the consensus algorithm SCAR, which dynamically adjusts the block time interval of the blockchain according to the network load, it can effectively avoid wasting storage resource when the transaction volume is small; also it can increase the block generation rate when the transaction volume is large, package the transaction into the blockchain in time, and guarantee the transaction to be confirmed quickly. The dynamic adjustment of the parameters on the chain also makes the blockchain system more flexible, improves governance efficiency, and reduces the difficulty and cost of governance. Generate block After the super node and block interval are determined, the node can take turns to generate a new block after the interval. At a specific blockchain height, if the number of super nodes is n, SCAR will assign a different block time to each super node. Block_time is as follows: In this formula, parent_block_time is the block time of the previous block and block_interval is dynamically calculated. timeout is used to prevent some super nodes from failing to be out of the block for a long time. The miner_index is the index value; under the same block height, different authorization nodes have different miner_index. The specific reasons and uses of the parameter settings will be explained below. As shown in the following figure, assume that there are 5 authorized super nodes A, B, C, D, E, their public keys are stored in a ordered list, which is determined by the DGP vote mentioned above. Assume that at height h1, the ordered miners list is [pubkey_A, pubkey_B, pubkey_C, pubkey_D, pubkey_E], and the five supernodes will create new blocks in turn. When a new block is created, the miners sign the block with an encryption algorithm and then append the signature to the block. In this way, other nodes can recover the miner's public key from the block by decryption, thereby verifying whether the miner has the right to create a block by comparing with the super node list. When a chain is signed by the majority of miners, the chain can be viewed as a permanent chain. For example, in the above image, the chain from the genesis block to the height of h3 is a permanent chain because it has been signed by miners D, E and A. If any miner wants to make a fork under height h3, this fork cannot be followed by most miners. Consensus algorithms can avoid forks effectively, but at least n/2+1 super nodes need to keep the consensus algorithm running (n is the number of super nodes, n/2 is integer division). The consensus algorithm defines the miners who are allowed to create the next block: A miner can create a new block in the following situations: It is authorized currently; The last n/2 blocks were not created by it. From the above definition, which super node can generate a new block: the node signed for the nearest n/2 blocks can be removed from the current miner list. For example, at the block height h2, the list of miners in the next block is calculated as shown. After selecting the three nodes (B, C, and D) that can generate the next block, we only need to set the super node list as an ordered list, and specify their priority order to avoid them competing for the next block of production. The miner_index in the formula is the priority index of the sorted miners list. The super node with a higher order will be assigned a earlier block_time, and then each super node will use the allocated block_time to create a new block and keep wait before the block_time is over. However, the super-node mode of the consortium blockchain also faces a problem: the failure of some nodes will lead to a sudden drop in network efficiency. In order to avoid the failure of some nodes, we add the following strategy to make sure the network works. We set timeout in the system parameters. If a super node fails to broadcast a new block due to a failure, the next super node will replace it after the timeout time and generate the block. As shown in the figure below, in the case of the above five super nodes, Miner B fails when producing a block with a height of h2+1. Subsequently, B's next node C in the supernode list will broadcast the new block it created after its block_interval+timeout time of parent_block_time. Conclusion While ensuring the performance of the blockchain, SCAR saves network bandwidth and hard disk consumption as much as possible by adjusting the parameters on the blockchain dynamically. It is more efficient and flexible than other consensus algorithms, and has more advantages in large-scale commercial applications. References [1] EOS.IO Technical White Paper v2: Consensus Algorithm (BFT-DPOS). https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md, March 16, 2018 [2] Aura - Authority Round - Wiki. https://wiki.parity.io/Aura [3] Qtum区块链指南. https://docs.qtum.site/zh/Qtum-Blockchain-Guide.html "},"Canal-Cross-Chain/":{"url":"Canal-Cross-Chain/","title":"Canal: A Cross-chain Trading Solution","keywords":"","body":"Canal：A Cross-chain Trading Solution Background Many cryptocurrencies have emerged with the development of the blockchain technology. These cryptocurrencies are recorded in their respective blockchain network, without communication with each other. Therefore, trading of cryptocurrencies is mainly conducted by means of cryptocurrency exchanges. Most exchanges are based on centralized services which are often challenged by security and privacy. Nevertheless, decentralized exchanges running on blockchains are receiving more and more attentions because of their data transparency, privacy protection, and real-time settlement. Currently most decentralized exchanges realize trading of tokens on the same blockchain, rather than cross-chain trading. It limits application scenarios of the decentralized exchange. This paper proposes a decentralized cryptocurrency exchange solution that enables cross-chain cryptocurrency trading. Here we only describe its basic idea and the design and development are still in process. We name this solution, Canal, because the canal realizes transportation and trading of goods among multiple cities. The original intention is that, after a user launches his own blockchain using the One-Click Blockchain service, he can use this solution to exchange his cryptocurrency with other blockchains, so as to facilitate cryptocurrency circulation. Related Works Decentralized Exchange Currently decentralized exchanges can be divided into the following two types. Order Matching Decentralized exchanges, including 0x [1] and Kyber Network [2], are classified as the type of order matching. Users use smart contract to post buy and sell orders, and then the system matches these orders. This kind of decentralized exchange can be regarded as migrating the trading process of centralized exchange to the blockchain, but the trading mechanism has not been changed. This type has following advantages: Transparency: The buy and sell orders are completely public; Security: Cryptocurrency is managed by smart contracts and is transferred to users' account immediately when orders are matched; Low costs: There are no other fee except blockchain gas. And following disadvantages: Transactions are processed on the blockchain, which slows down the trading process; When the market is inactive, it is hard to match orders between buyers and sellers, leading to weak liquidity. Automatic Pricing Bancor Network [3] realized automatic pricing between users and cryptocurrency liquidity pools. The trading process is as follows: Launch a contract, and deposit a certain amount of cryptocurrency A and B into the contract as initial fund pools. When a user needs to swap A for B, he first deposit A to the pool in the contract; then the contract calculates conversion rate according to amount of A, B in pools, and transfers corresponding amount of B to the user's account. If users continuously swap A for B, the amount of A in pool increases and B decreases, so that the conversion rate is lowered and the amount of B obtained is reduced. Advantages of automatic pricing are as follows: Do not need to pay a huge amount of money to build a trading pair. Users do not need to post any buy or sell and can trade with the pool at any time. Liquidity is ensured and users do not need to care about transaction depth. Disadvantages are as follows: A certain amount of cryptocurrency should be deposited to the system. Currently only support exchange of cryptocurrencies on the same blockchain. Cross-chain technology Blockchain networks cannot communicate with each other, which greatly limits blockchain application scenarios. The cross-chain technology aims to solve this problem and achieve data transferring from one blockchain to another. Existing cross-chain solutions only realize swap of tokens, but does not realize trading; that is, cryptocurrencies can only be swapped according to a pre-determined conversion rate but not a price varies depending on the market. This deters liquidity of cryptocurrency and restricts application of cross-chain technology. Cross-chain solutions can be divided into two types. Relay One type uses a main chain (sometimes called Hub or Relay) to connect side-chains, so as to achieve data transferring among side-chains. For example, Cosmos [4], Polkadot [5], etc., their basic ideas are generally the same: The main chain adopts a semi-decentralized consensus algorithm like dPoS (Delegated Proof of Stake) or PoA (Proof of Authority)in which blocks are generated by a few super nodes, or it may be called a consortium chain. Super nodes of the main chain monitor data changes of side-chains and generate corresponding data in the main chain; or they monitor changes of the main chain, and generate corresponding data in side-chains. In this way, communication between the main chain and side-chains is realized. The advantage of this cross-chain mode is that the data transmission process is fast and efficient and it can transmit any form of data; the disadvantage is that it leads to centralization, because the accuracy and completeness of cross-chain data depend on those super nodes of the consortium blockchain. Atomic Swap Atomic swap [6] uses blockchain scripts to realize swap of cryptocurrencies on different blockchain networks in an atomic way. The \"atomic\" here means two transactions posted by both parties of the swap must be completed or canceled simultaneously. The steps are as follows: Alice uses his token A to exchange token B owned by Bob. Alice creates a transaction to pay A to a script which needs a secret key only known by Alice and Bob's signature to unlock it. After Bob sees the transaction, Bob also creates a transaction to pay B to a script that requires the same secret key and Alice's signature to unlock it. Alice unlocks the transaction created by Bob with his secret key and signature, transferring B to his own address, and the secret key is uploaded to the blockchain with this operation. After Bob sees the secret key on the blockchain, Bob uses it and his signature to unlock the transaction created by Alice, transferring A to his address. If Alice or Bob quits in the middle, A and B will return to Alice and Bob respectively after a certain time, and the swap fails. The advantage of this cross-chain solution is that it's completely decentralized, and the swap process doesn't rely on any third party. The disadvantage is that 4 transactions must be executed to complete a swap, which is slow and inefficient. Algorithm Introduction This paper presents a decentralized cross-chain cryptocurrency trading solution. The trading process is completed by a consortium blockchain network with multiple smart contracts. Take such a scenario as an example: a cryptocurrency on side-chain A needs to be exchanged with another cryptocurrency on sidechain B. The trading process is completed through the main chain as a relay. Main Chain The main chain uses a consortium blockchain. Super nodes of the consortium blockchain are voted through all users or by any other method. Super nodes are responsible for verifying all transactions on the blockchain and generating new blocks. The main chain connects to all side-chains that need to be traded, ensuring data can be transmitted among chains. Meanwhile, the main chain is responsible for running the required smart contracts. Details of this solution will be described below. Cross-Chain The cross-chain part adopts the Relay type, which consists of two contracts. One is deployed on the main chain called the main contract and the other is deployed on the side chain called the sub-contract. The sub-contract is for users to deposit and withdraw tokens on the side-chain, as is similar to a centralized exchange. The main contract is used to synchronize users' transaction records and store their balances. The cross-chain steps are as follows: Deposit The user deposits cryptocurrency A to the sub-contract on side-chain A. The super nodes detect change of balance in the sub-contract and then add corresponding amount of token to the user's address in the main contract. Trading The user uses tokens in the main contract to request the trading API. API transfers converted cryptocurrency B to user's address. Withdraw The user request the sub-contract on side-chain B to start a withdrawal. The super nodes detect the withdrawal request, and then destroy user's token in the main contract as well as transfer corresponding amount of B to the user on side-chain B. Trading The trading process uses an automatic pricing model built on a smart contract. When the contract is initialized, a certain amount of cryptocurrency A and B are needed as fund pools to realize trading between A and B. The trading process is as follows: A user wants to convert a certain amount of cryptocurrency A into B. The user deposits A to the contract and the amount of A in fund pool increases. Contract calculates the amount of B that can be converted according to the amount of A and the balance of A and B in current fund pool. System transfers obtained amount of B from the fund pool to the user's address. The conversion in step 2 needs to follow the following principles: The less A in the fund pool, the higher the conversion rate from A to B. And it's the same for B. Any cryptocurrencies in the pool can not be used up, otherwise there will be unable to continue the conversion. Based on the principles above, the logic of the conversion can have various designs. For example: Assume that the balances of the cryptocurrency A and B in the fund pool are a0 and b0 respectively (a0 > 0, b0 > 0), and users want to convert A of amount Δa (Δa > 0) to obtain B of Δb (Δb > 0). Then the amount of B that can be converted to is: Δb = ( b0 * Δa ) / (a0 + Δa). It can be seen that Δb is an increasing function of b0 and is a decreasing function of a0, which is in accordance with above principle 1. It also can be seen that △b Summary In the design process, we got two thoughts. First, we realize that we shouldn't over-emphasize decentralization and sacrifice the efficiency of the trading process; because if the trading process is too slow, it will affect the user experience; and the need of decentralization in a consortium blockchain system can also be satisfied through voting for trusted super nodes. Second, the mode of automatic pricing is significantly better than order matching in actual usage, because for many new cryptocurrencies, the trading liquidity cannot be guaranteed, and the automatic pricing trading model effectively solves this problem. References [1] 0x protocol. https://www.0xproject.com/ [2] Kyber network. https://kyber.network/ [3] Bancor. https://www.bancor.network/ [4] Cosmos. https://cosmos.network/ [5] Polkadot. https://polkadot.network/ [6] Atomic Cross-Chain Swaps. https://arxiv.org/abs/1801.09515 "},"DDAO-Data-Management/":{"url":"DDAO-Data-Management/","title":"DDAO: Decentralized Data Access Object","keywords":"","body":"DDAO: Decentralized Data Access Object Introduction Data Management refers to the process of collecting, organizing, storing, processing, transmitting and retrieving different types of data. It is an important application area of the computer science. One of its goals is to efficiently store and manage complex, large amounts of data using computers, so that people can easily get access to the data. Another goal is to extract and derive valuable information from the data, and then use the information as a guidance for action and decision making. At present, enterprises mainly use centralized databases and file systems for data management. Large Internet companies develop their own systems, such as GFS (Google File System), SQL Server, etc., and deploy local services. Small and medium-sized companies connect to cloud services such as AWS, Aliyun, and delegate data management tasks to these third parties. Local and cloud data services have their own application scenarios and they maintain the basic data of many companies. Centralized storage is currently the main solution to data management, but there are serious storage problems in centralized databases and file systems around the world. Enterprises often store all their data and files in centralized databases and file systems. But centralized storage solutions often attract attacks from hackers, or they may be ruined by an accident. Enterprises sometimes have to face the loss of all their data resources and never get them back. Some business highly relys on data and such kind of loss may lead to huge risks. Although cloud service providers would promise to do data backup, but it has not solved the fundamental problem. Decentralization technologies, such as blockchain and IPFS, provide a new type of solutions to data management. By using encryption and consensus, data privacy and security are guaranteed. Since data are stored in a lot of nodes, there is no need to worry about data loss caused by failure of \bone single node, which improves security and reliability. Encryption and segmentation technologies control the read access and guarantee data privacy. At the same time, in order to ensure scalability, cluster technology is used. A cluster is a large group of nodes that store and manage data together, and it allows new nodes to join or expanding more clusters. However, at present, with the increasing number of decentralized systems, developers have to face high costs in selection, learning, development, deployment, and maintenance of these systems. Therefore we proposed the DDAO (Decentralized Data Access Object). Our goal is to develop a common library to access various decentralized systems with uniform interfaces, so as to perform CRUD (Create, Read, Update, Delete) operations. Through this library, developers can quickly read and write data in various decentralized systems and build their own applications without having to care about the underlying technology. Related Work With the development of blockchain technology and digital currency market, decentralized data storage and management technologies receive attentions from research fields and investment markets. Decentralized File System As a decentralized system, blockchain backs up data at every node, so it is not suitable for storing large-size files, such as pictures, videos and audios. In current blockchain applications, such kind of files are still stored in servers held by developers. This way leads to the centralization of these applications, which violates the essential meaning of blockchain. Decentralized file systems mainly include IPFS (InterPlanetary File System) [1], Swarm [2], Storj [3], and so on. Their basic method is to split the uploaded file into small pieces and then store them into nodes. When downloading the file, you can use the hash value of the file as an address to make a request to a node, and then you will get all the data pieces from the node and combine them into the whole file. In this way, one file can be separately stored in many nodes in a network, which achieves decentralization. One problem with these technologies is how to keep more nodes online to provide download services. Hence, some projects propose to add node incentive mechanisms to the decentralized file system so that online nodes can obtain revenues. In this way, the decentralized file system becomes a cloud storage service, in which users need to purchase the service during uploading and downloading processes so as to reward the nodes that provide the storage service. Several typical projects include Filecoin [4], Wolk [5], Fluence [6], and Sia [7]. Decentralized Database The decentralized file system enables decentralized storage of data, but after the data are uploaded, they cannot be further modified or retrieved, which limits its application in data management. Traditional centralized data management services usually use database systems such as MySQL or Redis to execute CRUD operations of data. Therefore, similar database services are required in the decentralized area. There are several projects having research on decentralized databases, including BigchainDB [8], Bluzelle [9], Ties.DB [10] and so on. Their basic idea is to upload database write requests to the blockchain through transactions, and then use database engines such as MongoDB to perform data indexing and process read requests. Using blockchain to build decentralized databases, effectively utilizes the mature decentralized architecture of blockchain systems, and has great advantages in stability and security. These projects are currently in their initial stages, and before their implementations mature, using smart contracts as a database service is also a viable alternative. Some projects are based on Ethereum + IPFS to develop their applications, using smart contracts written by Solidity for data management. Solidity supports data structures such as List, Map, Struct, etc., which are sufficient for common data management scenarios. These items are fully enumerated in [11]. System Description Decentralized systems have a variety of implementations, leading to high learning costs for developers. This article will design a common library for connecting upper-layer DApp applications to lower-layer decentralized systems, enabling CRUD operations for multiple decentralized systems. Developers can quickly build their own data management applications through this library without having knowledge about the underlying technology. At the same time, based on this library, a cloud service can be built to provide online CRUD interfaces of multiple decentralized systems, eliminating the cost of deploying and maintaining decentralized systems for developers. The system can be separated into three layers, namely DDMI (Decentralized Data Management Infrastructure), DDAO and DApp (Decentralized Application), which will be introduced as follows. DDMI The DDMI layer contains a variety of decentralized systems, including blockchains, decentralized databases, decentralized file systems, and more. These decentralized systems can be launched locally by the developer or deployed on a remote server, and then connected through a descriptor with uniform format. For example, the format of name://user:password@ip:port, that is, connecting to a local Unita node with port 13889 by unita://admin:123456@127.0.0.1:13889, or connecting to an IPFS node in LAN with 8080 port by ipfs://myname:mypasswd@192.168.1.2:8080. DDAO The DDAO layer is the core module proposed in this paper. Its main functions include (1) establishing connections to various decentralized systems, (2) abstracting to get compatible CRUD interfaces. For different types of decentralized systems, abstract interfaces are different: For blockchain systems, interfaces contain sending transactions, querying transactions, creating contracts, reading and writing contracts. For decentralized database systems, database interfaces such as create, find, insert, and update are included. For decentralized file systems, main interfaces such as file upload, download, and encryption are included. The design here needs to take into account the compatibility of different systems, so only some common functions are abstracted. At the same time, the interface used to send original commands is offered, so that developers can request some unique interfaces of each system. DApp The DApp can be JavaScript scripts running on browser or programs running on server. They may also be stored in the decentralized file system and later obtained through a specific address as an entry. The DApp initiates the DDAO instance, connects local or cloud decentralized systems, and performs CRUD operations on these systems, so as to realize data management applications. Multiple DDAO instances can be initiated within one DApp, in order to connect to multiple different decentralized systems. This allows data interaction with multiple decentralized systems in one application, enabling more features compared with traditional smart contract-based DApps. For example, cross-chain data transmission among multiple blockchains, or data visualization based on blockchain and file system. Application Scenario A large number of application scenarios is the best way to describe the value of DDAO. Based on DDAO, many decentralized applications will become easy to develop and implement. Decentralized Content Sharing DDAO can be used to build a blog, photo, music, video sharing platform. By using DDAO's write interfaces, users can publish texts, images, videos and other content to a decentralized file system such as IPFS, and then store their meta data (such as content address, release time, user ID, etc.) into a smart contract or a database. The DDAO read interfaces are used to filter, sort, and display the content. The advantage of such system is that the contents published by users is decentralized and cannot be tampered with. Decentralized Trading Platform Based on DDAO, you can build a trading platform like Taobao and Amazon. When a merchant uses DDAO write interfaces to upload its product information, the text and image are stored in a decentralized file system, and the meta data (such as price, quantity, classification, keywords, etc.) are stored in a smart contract or a database. When a customer browses the platform, DDAO read interfaces are used to search and filter products. Finally, the customer uses DDAO to connect to the blockchain to create orders, pay orders, and complete orders. The advantage of this platform is that the product information and transaction process are transparent and the payment process is convenient. Decentralized Cloud Storage Service Storage service providers register their information into a blockchain or a database via DDAO. When a user uploads a file, he needs to use blockchain tokens to purchase the service, and then uploads the file to a decentralized file system through DDAO, while the file information and address are stored in a smart contract or a database. When downloading, users browse the file information and address by using DDAO, and then download the file from the file system. The tokens consumed by the user are used to reward storage service providers, forming a complete economic ecology. Summary Decentralized data management has broad application prospects. Although, at present, decentralized databases and file systems are still under development, and immature infrastructure limits its application, it is conceivable that these systems will be implemented one after another in the near future. DDAO will also be widely used just like the DAO in current centralized systems. References [1] IPFS. https://ipfs.io/. [2] Swarm. https://swarm-guide.readthedocs.io/en/latest/. [3] Storj. https://storj.io/. [4] Filecoin. https://filecoin.io/. [5] Wolk. https://wolk.com/. [6] Fluence. https://fluence.one/. [7] Sia. https://sia.tech/. [8] BigchainDB. https://www.bigchaindb.com/. [9] Bluzelle. https://bluzelle.com/. [10] Ties.DB. https://tiesdb.com/. [11] Awesome IPFS. https://awesome.ipfs.io/. "},"Unita-Quick-Start/":{"url":"Unita-Quick-Start/","title":"Unita Quick Start","keywords":"","body":"Unita Quick Start Unita is the blockchain service provider based on open source project Qtum, provides enterprise application solutions that can be customized in various industries. Unita is based on consortium blockchain, builds a main chain with many side-chains system architecture, integrate one-click-blockchain, cross-chain transaction, data management and other modules and diversified supporting tools to form a one-stop blockchain enterprise service. We provide various services such as Unita full node wallet, faucet to get airdrop of UNT, blockchain explorer and blockchain stats,etc, to help you to use Unita. Unita URLs are as follws： Toolkits: Homepage, Qt-wallet download, Stats, Explorer, Faucet, One-click Blockchain. Docs: English, Chinese. Contents Download Run Wallet Use Wallet Get UNT through faucet Check transactions in Unita Explorer View Stats of Unita network Send Transactions Download full node wallet Find the latest release in Github and download wallet according to your device. Run Wallet Install the full node wallet and run it after downloaded. It will display window as picture below if there is no full node data existed, and then you should choose blockchain data path. You can use the defult path or custom it. Click 'OK' to enter the main interface of qt wallet. Wallet will connect nodes of Unita main network and download data of Unita blockchain in defult. You can also change chainId in 'Preference'(Mac users) to connect other blockchain network launched in 'One-Click-Blockchian'.(See mor details in 'One-Click-Launch-Chain'). Use Wallet If you own the privatekey of an Unita address with UNT, you can open Console in Help/Debug Window and input command \"importprivkey 'unitaprivkey'\" to import your address in wallet. If not, maybe you should get an Unita address by 'REQUEST PAYMENT' button in Recieve page or by command \"getnewaddress\". You can export privatekey by command \"dumpprivkey 'unitaaddress'\" after you have got a new address. Then, QT wallet will display some information such as balances in main interface: Balances Avaliable balance Pending balance Total balance Other Tokens Recent Transaction Get Airdrop through Faucet Enter Unita Faucet homepage. Unita Faucet airdrops UNT by verifying Twitter or Sina Weibo, and process is following: Choose a social network to login Follow the example below to publish content(Twitter content is '#Unita +UnitaAddress', Sina Weibo content is '#Unita# +UnitaAddress') Copy content URL to the form above and click \"Get Unita\" Watch the in process transaction list below and wait Let's take Twitter as an example. Log in your twitter account in https://mobile.twitter.com（https://mobile.twitter.com/ is Html5 version of Twitter, please use it so that you can get correct URL to get airdrop）. Follow the example in Faucet page to publish content including your Unita address. Copy URL of twitter you had published which included content example. Paste content URL to the form above and click \"Get Unita\", then watch the in process transaction list below and wait（Correct form of URL is https://mobile.twitter.com/${name}/status/${id}）. You will get UNT by Sina Weibo in the same way. Notice: In order to prevent the malicious over-application of UNT, we adopted the verification of social media plus verification code, and limited the number of applications. Each time a successful application will receive 50 UNTs, and a social media account can only apply once within 24 hours. Meanwhile, we allow the same Unita address to be claimed through different social accounts. Blockchain Explorer Then, you have got UNT and you can watch status of your Unita addresses and details of transactions in blockchain in Explorer page. Input Unita address in which you got airdrop of UNT in search field, then you will find transaction of recieving UNT in research results. Meanwhile, you can watch detail information of each block and tokens launched through smart contracts in Unita Explorer. You will get balance ranking of UNT and stats of miner addresses, even you can send transactions through \"Send Raw Transaction\" in explorer. Unita Blockchain Stats You can view stats and status of Unita main network in Stats page, which includes best block height, best block size, TPS and so on. Status of Supernodes in Unita network is also available. Send Transactions You can send transaction on the Send menu to realize to send certain number of UNTs to Unita address. Pay To: Here we’ll enter the address we want to send UNT to (Only Unita ignition addresses will work). Label: Optional, as it’s stated, it’s just a name/tag. Amount: Here we enter the amount of UNT we want to send. Once all fields are covered, we can click on the “Send” button and the UNT coins will be sent to the address we entered above. "},"One-Click-Launch-Chain/":{"url":"One-Click-Launch-Chain/","title":"Unita One-click Blockchain","keywords":"","body":"Unita One-click Blockchain Unita One-click Blockchain Download Sign up and Sign in Build Private Chain Generate Configuration Start Private Chain Connect Private Chain Seed Node Build Consortium Chain Configuration Start Online Governance About DGP Modify Miners List Modify System Parameters Download Download the latest installation package from Github and install it to any directory. Sign up and Sign in Run unitad or unita-qt to start the main chain of Unita. Open the Help - Debug window - Console of QT wallet or execute the RPC command by unita-cli. Execute the getnewaddress command, generate a new address as an account and record it. Execute the dumpprivkey command, get the private key of the new address, and record it. Open the Unita One-click blockchain, click LOGIN to enter the login page. Execute the signmessage command, use the generated address to sign the message in the login page, and fill in the login page with the result of signature. Click LOGIN to complete the login. Build Private Chain In order to make it easier to understand, we will first introduce how to build own private chain. Generate Configuration Click LAUNCH A NEW CHAIN，enter the page of release new chain.After filling in all the information of the new chain,click SUBMIT to release the new chain.The meaning of each field is as follows. Chain id:the name of the chain,only support lowercase letters and numbers,unique.Such as mychain123. Token name:the name of the token,only support capital letters and numbers,unique.Such as BTC、UNT. Description:the description of the chain,to introduce the chain,also used to generate genesis block.Such as:my first blockchain. Message Header:Network head packet,used to distinguish different chains in network transmission.4 byte length,sixteen decimal representation,8 0-9a-f characters,such as:1234fedc. Algorithm:Consensus algorithm.Only PoA consensus is supported now,more choices will be provided in the future.Want to know more about PoA,reference SCAR. Miner list:the list of PoA miners,one or more address,separated by commas.When we build the first private chain,use the default account. Block interval、Timeout:See the SCAR docs, you can use the default value directly. Default port:The default port address. Dns seed、Ip seed:The default connection seed node in the network when new node join.Because it is a private chain,left empty here. Init Reward:Initial rewards for each block. Halving interval:The reward will be half after several blocks. Halving times:Times of half. Start Private Chain We create a chain named xunita (Link) ,the chain by the following steps. Use unitad -chain=xunita or After the configuration and restart in unita-qt as shown in the following figure,start the chain named xunita. Execute getpoaminerlist,see the list of miners. Execute importprivkey,import the miner's private key. Execute setpoaminer,use miner's account to mine.It needs to run this command to mine after node restarts. We can see that the number of block is increasing from the QT purse or execute getblockchaininfo command. New chain startup success,try trading or intelligent contracts！ Connect Private Chain Assuming that we have started the private chain xunita on the machine A and mine,then we need to start the node on the machine B and access the private chain. Execute unitad -chain=xunita or do configuration to start node of xunita in unita-qt on machine B. Execute addnode \"ip_A\" add,connect the node on machine A. After connecting, we can view the node situation through the getpeerinfo command. Try to trade with each other between the two nodes. Seed Node The new node of the block chain can quickly find the network by connecting the seed node (seed) at the time of startup,save the steps of addnode at the above text.The seed node can be a IP or a domain name,and there are nodes running on the corresponding servers. The following explains the process of configuring the seed node. Build a new chain named xxxxx (Link) ,fill in own domain name in Dns seed,or fill in server address in Ip seed.If you use the domain name,please parse the domain name to your server. Dns seed: beta.unita.network Ip seed: 47.88.61.227 Enter server（47.88.61.227）,use ./unitad -chain=xxxxx to start the node.root@47.88.61.227:./unitad -chain=xxxxx -daemon Configuration is completed,any machine starting the xxxxx chain will connect to the seed node to get data.You can see the nodes on the connection through the getpeerinfo command. Build Consortium Chain The difference between consortium chain and private chain is that the consortium chain is maintained by many miners.EOS is a typical consortium chain:first we get multiple super nodes through the campaign,then these super nodes are responsible for producing the blocks and get the reward of the blocks. Configuration Build a new consortium chain named unitax（Link) .Compared to private chain,the main change is that the miner list field has 3 miners' addresses, separated by commas. Miner list UgW1vTs3bA9pb73EeJ8N9M712w6Z7Evbru,Um8w24duUhf1XE8NVcbzn91tCeiuRWU188,UjBnjZ39N7U3vRkKoknntkkfiKzFbphZRR Start Start 3 nodes on the seed server,and open mining by importprivkey and setpoaminer command.We can see that the height of block is increasing and the system is running normally by the getblockchaininfo command.We can see the miner of every block by the getblock command. Online Governance About DGP Modify Miners List Modify System Parameters "}}